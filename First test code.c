#pragma config(Sensor, in1,    liftP,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, pivEncoder,     sensorQuadEncoder)
#pragma config(Motor,  port1,           INtake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           liftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           MobileL,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           MobileR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           pivR,           tmotorNone, openLoop)
#pragma config(Motor,  port7,           pivL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LDrive,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!

#include "Vex_Competition_Includes.c"

#define MAX -1245

	int StillSpeedSet = 15;

//--###################--Motor Voids--###################--//

void setDrivePower(int left, int right){   // Defining all of the motors for the drive
	motor[LDrive] = left;
	motor[RDrive] = right;
}

void setLiftPower(int power){   // Defining all of the motors for the lift
	motor[liftR] = power;
	motor[liftL] = power;

}

void setChainPower(int cpower){		// Defining all of the motors for the chain bar
	motor[pivR] = cpower;
	motor[pivL] = cpower;
}

void setIntakePower(int Ipower){		// Defining all of the motors for the intake
	motor[INtake] = Ipower;
}

void setMobilePower(int Mpower){		// Defining all of the motors for the intake
	motor[MobileL] = Mpower;
	motor[MobileR] = Mpower;
}
//--###################--Aton Voids--###################--//


int maxDisp = 0;

void pivControl(){

	// get lift input...

	int pos = SensorValue[pivEncoder];
	int disp = pos - MAX;

	if (disp > maxDisp)

		maxDisp = disp;


	if (pos < maxDisp)

		SensorValue[pivEncoder] = 0;
		maxDisp = 0;

	if (pos < 0)
		SensorValue[pivEncoder] = 0;

}


void Liftaton(int targetVal, int liftspeed=127)         // Defining /LIFT/ Atonomus position.
{
	int direction = sgn(targetVal - SensorValue[liftP]);

	while (direction == sgn(targetVal - SensorValue[liftP])) {
		setLiftPower(direction * liftspeed);
	}
																																	// Bottom value 2440
	setLiftPower(0);																								// Top Value 900
}

void UntilDrive (int ticks)
{

	SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

	int RightEncoderPos = abs(SensorValue[rightEncoder]);
  int LeftEncoderPos = abs(SensorValue[leftEncoder]);

	setDrivePower(127, 127);
	waitUntil(RightEncoderPos || LeftEncoderPos == ticks);
	stop();
}


void Atondrive(int ticks, int power)
{
	  //Clear Encoders
  SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

  int RightEncoderPos = SensorValue[rightEncoder];
  int LeftEncoderPos = abs(SensorValue[leftEncoder]);

  while(RightEncoderPos < ticks)  // While less than 5 rotations on the leftEncoder...
  {
    //...Move Forward
  	if (LeftEncoderPos > RightEncoderPos) //straiten left
  	{
    	motor[RDrive] = 127;
    	motor[LDrive] = 125;
    }

    if (RightEncoderPos < LeftEncoderPos) //straiten right
  	{
    	motor[LDrive] = 127;
    	motor[RDrive] = 125;
    }

    if (RightEncoderPos == LeftEncoderPos) //else just drive strait at "power" value
  	{
    	motor[LDrive] = power;
    	motor[RDrive] = power;
    }
			setDrivePower(0, 0);
  }
}

void SturnL(int ticks)
{
	  //Clear Encoders
  SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

  while(abs(SensorValue[rightEncoder]) < ticks)  // While less than 5 rotations on the leftEncoder...
  {
   	motor[LDrive] = -127;
		motor[RDrive] = 127;
  }
}


void Pivot(int ticks)
{
	  //Clear Encoders
  SensorValue[pivEncoder] = 0;

  while(SensorValue[pivEncoder] < ticks)  // While less than 5 rotations on the leftEncoder...
  {

    	motor[pivR] = 127;
			motor[pivL] = 127;

  }
}
//--####################################################--//

void pre_auton()
{

	bStopTasksBetweenModes = true;

}






	//--###################--Autonomous Mode--###################--//


task autonomous()
{
	Atondrive(1000, 100);
}



	//--###################--User Control--###################--//

task usercontrol()
{
	while (true)
	{
		setDrivePower(vexRT[Ch2], vexRT[Ch3]);




	//----------------------Lift Controll------------------------//


		if( vexRT[Btn5D] == 1 )
		{

			setLiftPower(127);


		}

		else if( vexRT[Btn5U] == 1 )
		{

			setLiftPower(-127);


		}

		else
		{
			setLiftPower(0);
		}



	//----------------------Chain Bar Control (pivot)------------------------//
		if( vexRT[Btn7U] == 1)
		{
			setChainPower(127);

			StillSpeedSet;

		}

		else if( vexRT[Btn7D] == 1)
		{
			setChainPower(-127);

			StillSpeedSet;

		}

		else
		{
			setChainPower(-15);
		}


	//----------------------Intake Control------------------------//
		if( vexRT[Btn6U] == 1)
		{
			setIntakePower(127);

			StillSpeedSet;

		}

		else if( vexRT[Btn6D] == 1)
		{
			setIntakePower(-127);

			StillSpeedSet;


		}

		else
		{
			setIntakePower(0);
		}


		//----------------------Moblie Goal Lift------------------------//
		if( vexRT[Btn8U] == 1)
		{
			setMobilePower(127);

		}

		else if( vexRT[Btn8D] == 1)
		{
			setMobilePower(-127);

		}

		else
		{
			setMobilePower(0);
		}
	}
}
