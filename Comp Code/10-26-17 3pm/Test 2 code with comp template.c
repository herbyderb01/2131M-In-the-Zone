#pragma config(Sensor, in1,    liftP,          sensorPotentiometer)
#pragma config(Sensor, in2,    pivP,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           INtake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           liftL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           MobileL,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           MobileR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           pivR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           pivL,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LDrive,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#include "BackOver Functions 2017-18.c"

int liftstillspeed;
								//-------------Motor Void Set-Up--------------//

void setDrivePower(int left, int right){   // Defining all of the motors for the -DRIVE-
	motor[LDrive] = left;
	motor[RDrive] = right;
}

void setLiftPower(int power){   // Defining all of the motors for the -LIFT-
	motor[liftR] = power;
	motor[liftL] = power;
}

void setChainPower(int cpower){		// Defining all of the motors for the -CHAIN BAR-
	motor[pivR] = cpower;
	motor[pivL] = cpower;
}

void setIntakePower(int Ipower){		// Defining all of the motors for the -INTAKE-
	motor[INtake] = Ipower;
}

void setMobilePower(int Mpower){		// Defining all of the motors for the -MOBILE GOAL INTAKE-
	motor[MobileL] = Mpower;
	motor[MobileR] = Mpower;
}

								//-------------Motor Void Set-Up--------------//

///////////LIFT//////////////
void Liftaton(int targetVal, int liftspeed=127)         // Defining /LIFT/ Atonomus position.
{
	int direction = sgn(targetVal - SensorValue[liftP]);

	while (direction == sgn(targetVal - SensorValue[liftP])) {
		setLiftPower(direction * liftspeed);
	}
																																	// Bottom value 2440
	setLiftPower(0);																								// Top Value 900
}

/*int absRightEncoder() {
	return abs(SensorValue[rightEncoder]);
}
*/
void AutoStrait(int distance, int power)
{
	while(SensorValue[rightEncoder]<distance)
	{
	if (abs(SensorValue[rightEncoder]) > (abs(SensorValue[leftEncoder])))
		{
				motor[LDrive] = power;
				motor[RDrive] = power-50;
		}
		if (abs(SensorValue[leftEncoder]) > (abs(SensorValue[rightEncoder])))
		{
				motor[LDrive] = power-2;
				motor[RDrive] = power;
		}
		if (abs(SensorValue[rightEncoder]) == (abs(SensorValue[leftEncoder])))
		{
				motor[LDrive] = power;
				motor[RDrive] = power;
		}
	}
	SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;


}


void Atondrive(int ticks, int power)
{
	  //Clear Encoders
  SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

  //int LeftEncoderPos = abs(SensorValue[leftEncoder]);

///forward
  while(abs(SensorValue[rightEncoder]) < ticks*.6)
  {
  	motor[LDrive] = power;
		motor[RDrive] = power;

		AutoStrait(ticks, power);
	}
	while(abs(SensorValue[rightEncoder]) < ticks*.8)
  {
  	motor[LDrive] = power/2;
		motor[RDrive] = power/2;

		AutoStrait(ticks, power);

	}
	while(abs(SensorValue[rightEncoder]) < ticks)
  {
  	motor[LDrive] = power/4;
		motor[RDrive] = power/4;

		AutoStrait(ticks, power);

	}
		motor[LDrive] = 0;
		motor[RDrive] = 0;
}



/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{

  bStopTasksBetweenModes = true;


}
///////////////////////////////////////////////////////////////////////////////
void AutoStackUp()
{
	liftRRequestedValue = 2300;

}

void AutoStackDown()
{
	liftRRequestedValue = 2300;
}

task drive()
{

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	chainRRequestedValue = 2300;

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{

startTask(chainRController);
chainRRequestedValue = 1200;
  while (true)
	{
		setDrivePower(vexRT[Ch3], vexRT[Ch2]);

	//----------------------Lift Controll------------------------//

		if( vexRT[Btn5D] == 1 )
		{
			setLiftPower(-127);
			liftstillspeed=-15;
		}

		else if( vexRT[Btn5U] == 1 )
		{
			setLiftPower(127);
			liftstillspeed=-10;
		}
		//still speeds
		else if (SensorValue[liftP] <2000)
		{
			setLiftPower(10);
		}
		else
		{
			setLiftPower(liftstillspeed);
		}



	//----------------------Intake Control------------------------//
		if( vexRT[Btn6U] == 1)
		{
			setIntakePower(127);
		}

		else if( vexRT[Btn6D] == 1)
		{
			setIntakePower(-127);
		}

		else
		{
			setIntakePower(25);
		}


		//----------------------Moblie Goal Lift------------------------//
		if( vexRT[Btn7U] == 1)
		{
			setMobilePower(127);
		}

		else if( vexRT[Btn7D] == 1)
		{
			setMobilePower(-127);
		}

		else
		{
			setMobilePower(0);
		}

		//----------------------PIV Control with PID------------------------//
		if( vexRT[Btn8D] == 1)
		{
			chainRRequestedValue = 1200;
		}

		else if( vexRT[Btn8R] == 1)
		{
			chainRRequestedValue = 2850;
		}

		else if( vexRT[Btn8L] == 1)
		{
			chainRRequestedValue = 1900;
		}
		else if( vexRT[Btn8U] == 1)
		{
			chainRRequestedValue = 200;
		}
	}
}
